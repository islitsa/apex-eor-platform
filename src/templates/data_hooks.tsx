/**
 * Data Fetching Hooks - Phase 3A
 *
 * These hooks connect to the backend data API and fetch real data.
 * Auto-generated by the React Developer agent.
 */

import { useState, useEffect } from 'react';

// API Configuration
const API_BASE_URL = 'http://localhost:8000';

// ========================================
// Types
// ========================================

export interface DataSource {
  name: string;
  data_types: string[];
  stages: string[];
  row_count: number;
  columns: string[];
  schema: Record<string, string>;
}

export interface QueryRequest {
  source: string;
  data_type?: string;
  columns?: string[];
  filters?: Record<string, any>;
  limit?: number;
  offset?: number;
}

export interface QueryResponse<T = any> {
  data: T[];
  total: number;
  returned: number;
  offset: number;
}

export interface Pipeline {
  id: string;
  name: string;
  display_name: string;
  status: string;
  metrics: {
    file_count: number;
    record_count: number;
    data_size: string;
  };
  stages: Array<{
    name: string;
    status: string;
  }>;
  files: any;
}

export interface PipelinesResponse {
  pipelines: Pipeline[];
  summary: {
    total_pipelines: number;
    total_records: number;
    total_size: string;
    datasets_available: number;
  };
}

// ========================================
// Custom Hooks
// ========================================

/**
 * Fetch pipeline metadata (pipeline stages, health, file structure)
 * This is different from useDataSources which lists data source names.
 * Use this for pipeline dashboards showing download/extract/parse/validate stages.
 */
export function usePipelines() {
  const [data, setData] = useState<PipelinesResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch(`${API_BASE_URL}/api/pipelines`)
      .then(res => res.json())
      .then((result: PipelinesResponse) => {
        setData(result);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, []);

  return { data, loading, error };
}

/**
 * Fetch list of all available data sources (just names)
 * For pipeline metadata with stages, use usePipelines() instead.
 */
export function useDataSources() {
  const [sources, setSources] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch(`${API_BASE_URL}/api/sources`)
      .then(res => res.json())
      .then(data => {
        setSources(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, []);

  return { sources, loading, error };
}

/**
 * Fetch metadata about a specific data source
 */
export function useDataSourceInfo(source: string) {
  const [info, setInfo] = useState<DataSource | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!source) return;

    fetch(`${API_BASE_URL}/api/sources/${source}/info`)
      .then(res => res.json())
      .then(data => {
        setInfo(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [source]);

  return { info, loading, error };
}

/**
 * Fetch data from a source with pagination
 */
export function useDataSource<T = any>(
  source: string,
  options: {
    limit?: number;
    offset?: number;
    columns?: string;
    autoFetch?: boolean;
  } = {}
) {
  const { limit = 1000, offset = 0, columns, autoFetch = true } = options;

  const [data, setData] = useState<T[]>([]);
  const [total, setTotal] = useState(0);
  const [loading, setLoading] = useState(autoFetch);
  const [error, setError] = useState<string | null>(null);

  const fetchData = () => {
    if (!source) return;

    setLoading(true);
    setError(null);

    const params = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString(),
    });

    if (columns) {
      params.append('columns', columns);
    }

    fetch(`${API_BASE_URL}/api/sources/${source}/data?${params}`)
      .then(res => res.json())
      .then((result: QueryResponse<T>) => {
        setData(result.data);
        setTotal(result.total);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  };

  useEffect(() => {
    if (autoFetch) {
      fetchData();
    }
  }, [source, limit, offset, columns, autoFetch]);

  return { data, total, loading, error, refetch: fetchData };
}

/**
 * Advanced query with filters
 */
export function useDataQuery<T = any>(request: QueryRequest, autoFetch = true) {
  const [data, setData] = useState<T[]>([]);
  const [total, setTotal] = useState(0);
  const [loading, setLoading] = useState(autoFetch);
  const [error, setError] = useState<string | null>(null);

  const fetchData = () => {
    if (!request.source) return;

    setLoading(true);
    setError(null);

    fetch(`${API_BASE_URL}/api/query`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    })
      .then(res => res.json())
      .then((result: QueryResponse<T>) => {
        setData(result.data);
        setTotal(result.total);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  };

  useEffect(() => {
    if (autoFetch) {
      fetchData();
    }
  }, [JSON.stringify(request), autoFetch]);

  return { data, total, loading, error, refetch: fetchData };
}

// ========================================
// Utility Functions
// ========================================

/**
 * Check if API is running
 */
export async function checkApiHealth(): Promise<boolean> {
  try {
    const response = await fetch(`${API_BASE_URL}/`);
    const data = await response.json();
    return data.status === 'running';
  } catch {
    return false;
  }
}
