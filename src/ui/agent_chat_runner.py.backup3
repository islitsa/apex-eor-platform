"""
Agent Chat Runner V2 - Auto-starts with context and streams ALL output to Streamlit

Improvements:
1. Auto-populates prompt from context and starts running immediately
2. Captures and displays ALL agent chatter in Streamlit (not terminal)
3. No button clicking needed - just watch it work!
"""

import streamlit as st
import sys
import io
import threading
import queue
from pathlib import Path
from typing import Dict, Any, Optional
import time
import subprocess
import webbrowser
from datetime import datetime
from contextlib import redirect_stdout, redirect_stderr

# Add project root to path
project_root = Path(__file__).resolve().parent.parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from src.agents.ui_orchestrator import UICodeOrchestrator
from src.builders.dashboard_builder import DashboardBuilder
from shared_state import PipelineState, SessionState


class OutputCapture:
    """Captures stdout/stderr and sends to Streamlit"""

    def __init__(self, message_callback):
        self.message_callback = message_callback
        self.buffer = io.StringIO()
        self.queue = queue.Queue()

    def write(self, text):
        """Capture writes and send to callback"""
        if text and text != '\n':
            self.buffer.write(text)
            # Send complete lines to callback
            if '\n' in text:
                lines = self.buffer.getvalue().split('\n')
                for line in lines[:-1]:  # All complete lines
                    if line.strip():
                        self.message_callback('system', f"```\n{line}\n```")
                # Keep incomplete line in buffer
                self.buffer = io.StringIO()
                if lines[-1]:
                    self.buffer.write(lines[-1])

    def flush(self):
        pass


class AgentChatRunnerV2:
    """Enhanced auto-running agent chat with full output capture"""

    def __init__(self):
        st.set_page_config(
            page_title="Agent UI Generator",
            page_icon="ü§ñ",
            layout="wide"
        )

        # Initialize session state
        if 'messages' not in st.session_state:
            st.session_state.messages = []
        if 'status' not in st.session_state:
            st.session_state.status = 'initializing'
        if 'generation_started' not in st.session_state:
            st.session_state.generation_started = False
        if 'dashboard_code' not in st.session_state:
            st.session_state.dashboard_code = None
        if 'dashboard_file' not in st.session_state:
            st.session_state.dashboard_file = None
        if 'context' not in st.session_state:
            st.session_state.context = None
        if 'auto_started' not in st.session_state:
            st.session_state.auto_started = False
        if 'prompt' not in st.session_state:
            st.session_state.prompt = None
        if 'output_buffer' not in st.session_state:
            st.session_state.output_buffer = []

    def add_message(self, role: str, content: str, metadata: Dict = None):
        """Add a message to the chat"""
        message = {
            'role': role,
            'content': content,
            'metadata': metadata or {},
            'timestamp': datetime.now().isoformat()
        }
        st.session_state.messages.append(message)

        # Also add to output buffer for terminal-style display
        if role in ['stdout', 'stderr', 'system'] and '```' in content:
            # Extract code block content for terminal view
            clean_content = content.replace('```\n', '').replace('\n```', '')
            st.session_state.output_buffer.append(clean_content)

    def render_message(self, msg: Dict):
        """Render a chat message"""
        role = msg['role']
        content = msg['content']

        # Role styles with emojis
        role_styles = {
            'system': ('üé≠', 'System', '#8E24AA'),
            'ux_designer': ('üé®', 'UX Designer', '#1E88E5'),
            'gradio_developer': ('‚öôÔ∏è', 'Gradio Developer', '#43A047'),
            'orchestrator': ('üé≠', 'Orchestrator', '#8E24AA'),
            'builder': ('üèóÔ∏è', 'Dashboard Builder', '#F57C00'),
            'stdout': ('üìü', 'Output', '#666666'),
            'stderr': ('‚ö†Ô∏è', 'Error', '#FF5722'),
            'prompt': ('üí≠', 'Prompt', '#00ACC1'),
        }

        emoji, name, color = role_styles.get(role, ('‚ÑπÔ∏è', role.title(), '#999'))

        # Special handling for stdout/stderr (show as code)
        if role in ['stdout', 'stderr']:
            if content.strip():
                st.code(content, language='text')
        else:
            with st.chat_message(name, avatar=emoji):
                if '**' in content or '\n' in content or '```' in content:
                    st.markdown(content)
                else:
                    st.write(content)

                # Show metadata if present
                if msg.get('metadata') and len(msg['metadata']) > 0:
                    with st.expander("üìä Details", expanded=False):
                        st.json(msg['metadata'])

    def generate_prompt_from_context(self, context: Dict) -> str:
        """Generate an intelligent prompt based on context"""
        datasets = list(context.get('data_sources', {}).keys())
        total_records = context.get('summary', {}).get('human_readable_records', 'Unknown')

        # Determine UI type based on data
        if 'production' in str(datasets).lower():
            ui_type = "production monitoring dashboard"
        elif 'permits' in str(datasets).lower():
            ui_type = "permit tracking interface"
        elif 'completions' in str(datasets).lower():
            ui_type = "well completion analyzer"
        else:
            ui_type = "data exploration dashboard"

        prompt = f"""Create a {ui_type} with the following requirements:

1. Display data from {len(datasets)} sources: {', '.join(datasets)}
2. Handle {total_records} total records efficiently
3. Include interactive filtering and drill-down capabilities
4. Use Material Design 3 patterns for modern UX
5. Implement real-time data refresh capabilities
6. Add export functionality for reports

Focus on usability and performance for petroleum engineering workflows."""

        return prompt

    def load_and_start(self):
        """Load context and immediately start generation"""
        # Load context from shared state
        try:
            context = PipelineState.load_context(check_freshness=True)

            if context is None:
                self.add_message('system', "[ERROR] No pipeline context found. Please run pipeline first.")
                st.session_state.status = 'error'
                return False

            st.session_state.context = context

            # Generate prompt from context
            prompt = self.generate_prompt_from_context(context)
            st.session_state.prompt = prompt

            # Show what we're doing
            sources = len(context.get('data_sources', {}))
            total_records = context.get('summary', {}).get('human_readable_records', 'Unknown')

            self.add_message('system', "[OK] Context loaded from pipeline", {
                'data_sources': sources,
                'total_records': total_records,
                'datasets': list(context.get('data_sources', {}).keys())
            })

            self.add_message('prompt', f"**Generated Prompt:**\n\n{prompt}")

            return True

        except Exception as e:
            self.add_message('system', f"[ERROR] Error loading context: {e}")
            st.session_state.status = 'error'
            return False

    def generate_with_capture(self):
        """Generate dashboard with full output capture"""
        context = st.session_state.context
        prompt = st.session_state.prompt

        # Create placeholder for live terminal output
        terminal_placeholder = st.empty()

        def update_terminal():
            """Update terminal display with buffer content"""
            if st.session_state.output_buffer:
                terminal_content = '\n'.join(st.session_state.output_buffer[-50:])  # Last 50 lines
                terminal_placeholder.code(terminal_content, language='text')

        # Step 1: Build base dashboard
        self.add_message('builder', "**Step 1/3:** Building base dashboard...")
        update_terminal()

        try:
            # Capture all output during generation
            capture = OutputCapture(self.add_message)

            with redirect_stdout(capture), redirect_stderr(capture):
                builder = DashboardBuilder()
                base_code = builder.build(context)

            self.add_message('builder', f"[OK] Base dashboard generated: {len(base_code)} characters")
            update_terminal()

        except Exception as e:
            self.add_message('builder', f"[ERROR] Error: {e}")
            st.session_state.status = 'error'
            return

        # Step 2: Generate with agents (with output capture)
        self.add_message('orchestrator', "**Step 2/3:** Launching two-agent system...")
        update_terminal()

        try:
            # Create orchestrator that streams to our chat
            orchestrator = CaptureOrchestrator(
                message_callback=self.add_message,
                terminal_callback=update_terminal
            )

            # Build requirements from prompt
            requirements = {
                'screen_type': 'dynamic_dashboard',
                'intent': prompt,
                'data_sources': context.get('data_sources', {})
            }

            # Generate with full output capture
            with redirect_stdout(capture), redirect_stderr(capture):
                navigation_code = orchestrator.generate_ui_code(requirements, context)

            # Combine codes
            final_code = self.inject_navigation(base_code, navigation_code)

            self.add_message('orchestrator', f"[OK] Complete! Generated {len(final_code)} characters")
            update_terminal()

        except Exception as e:
            self.add_message('orchestrator', f"[ERROR] Error: {e}")
            final_code = base_code

        # Step 3: Save and prepare launch
        self.add_message('system', "**Step 3/3:** Saving generated code...")
        update_terminal()

        try:
            output_file = project_root / "generated_ui.py"
            output_file.write_text(final_code, encoding='utf-8')

            st.session_state.dashboard_code = final_code
            st.session_state.dashboard_file = str(output_file)

            self.add_message('system', f"[OK] **Saved to:** `{output_file.name}`", {
                'file_path': str(output_file),
                'file_size': len(final_code)
            })

            # Save to session
            SessionState.update_session(
                last_dashboard_file=str(output_file),
                last_generation_time=datetime.now().isoformat(),
                last_prompt=prompt
            )

            st.session_state.status = 'complete'
            update_terminal()

        except Exception as e:
            self.add_message('system', f"[ERROR] Error saving: {e}")
            st.session_state.status = 'error'

    def inject_navigation(self, base_code: str, navigation_code: str) -> str:
        """Inject navigation code into base dashboard"""
        placeholder = "# NAVIGATION_HANDLER_PLACEHOLDER"
        if placeholder in base_code:
            return base_code.replace(placeholder, navigation_code)
        return base_code + "\n\n" + navigation_code

    def launch_gradio(self):
        """Launch the generated Gradio dashboard"""
        if not st.session_state.dashboard_file:
            st.error("No dashboard file to launch!")
            return

        try:
            dashboard_file = st.session_state.dashboard_file
            process = subprocess.Popen(
                ['python', dashboard_file],
                cwd=str(project_root),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            time.sleep(2)
            webbrowser.open('http://127.0.0.1:7860')
            self.add_message('system', "[OK] Dashboard launched at http://127.0.0.1:7860")
        except Exception as e:
            self.add_message('system', f"[ERROR] Error launching: {e}")

    def run(self):
        """Main render loop"""

        # Header
        st.title("ü§ñ AI-Powered UI Generator")
        st.markdown("**Watch as AI agents collaborate to build your interface!**")

        # Status bar
        col1, col2, col3 = st.columns([2, 1, 1])

        with col1:
            if st.session_state.status == 'initializing':
                st.info("‚è≥ Loading context and preparing prompt...")
            elif st.session_state.status == 'generating':
                st.warning("üîÑ Agents are working on your UI...")
            elif st.session_state.status == 'complete':
                st.success("‚úÖ UI generation complete!")
            elif st.session_state.status == 'error':
                st.error("‚ùå Generation failed - check messages")

        with col2:
            if st.session_state.status == 'complete' and st.session_state.dashboard_file:
                if st.button("üöÄ Launch UI", type="primary"):
                    self.launch_gradio()

        with col3:
            if st.button("üîÑ Regenerate"):
                st.session_state.messages = []
                st.session_state.status = 'initializing'
                st.session_state.generation_started = False
                st.session_state.auto_started = False
                st.session_state.output_buffer = []
                st.rerun()

        st.markdown("---")

        # Two-column layout: Chat and Terminal
        col_chat, col_terminal = st.columns([1, 1])

        with col_chat:
            st.subheader("üí¨ Agent Conversation")

            # Chat container with messages
            chat_container = st.container(height=600)
            with chat_container:
                for msg in st.session_state.messages:
                    if msg['role'] not in ['stdout', 'stderr']:  # Don't show raw output in chat
                        self.render_message(msg)

        with col_terminal:
            st.subheader("üìü Terminal Output")

            # Terminal-style output
            terminal_container = st.container(height=600)
            with terminal_container:
                if st.session_state.output_buffer:
                    terminal_text = '\n'.join(st.session_state.output_buffer)
                    st.code(terminal_text, language='text')
                else:
                    st.code("Waiting for output...", language='text')

        # AUTO-START GENERATION (only once)
        if not st.session_state.auto_started:
            st.session_state.auto_started = True

            # Load context first
            if self.load_and_start():
                st.session_state.status = 'generating'
                st.rerun()

        # Start generation if ready
        elif st.session_state.status == 'generating' and not st.session_state.generation_started:
            st.session_state.generation_started = True
            self.generate_with_capture()
            st.rerun()


class CaptureOrchestrator(UICodeOrchestrator):
    """Orchestrator that captures ALL output and streams to Streamlit"""

    def __init__(self, message_callback=None, terminal_callback=None):
        super().__init__()
        self.message_callback = message_callback
        self.terminal_callback = terminal_callback

    def emit(self, role: str, content: str, metadata: Dict = None):
        """Emit message to Streamlit"""
        if self.message_callback:
            self.message_callback(role, content, metadata)
        if self.terminal_callback:
            self.terminal_callback()

    def generate_ui_code(self, requirements: Dict, context: Dict) -> str:
        """Generate UI code with full output streaming"""

        # All print statements from agents will be captured by redirect_stdout

        # PHASE 1: UX Designer
        self.emit('orchestrator', "**PHASE 1:** UX Design")

        print("[UX Designer] Analyzing requirements...")
        print(f"[UX Designer] Screen type: {requirements.get('screen_type')}")
        print(f"[UX Designer] Data sources: {len(requirements.get('data_sources', {}))}")

        self.emit('ux_designer', "üé® Starting design process...")

        design_spec = self.ux_designer.design(requirements)

        print(f"[UX Designer] Created {len(design_spec.components)} components")
        print(f"[UX Designer] Design patterns: {design_spec.patterns}")

        self.emit('ux_designer', f"[OK] Design complete!", {
            'components': len(design_spec.components),
            'patterns': design_spec.patterns
        })

        # PHASE 2: Gradio Developer
        self.emit('orchestrator', "**PHASE 2:** Implementation")

        print("[Gradio Dev] Received design specification")
        print(f"[Gradio Dev] Converting {len(design_spec.components)} components to Gradio")

        self.emit('gradio_developer', "‚öôÔ∏è Building Gradio implementation...")

        gradio_code = self.gradio_developer.build(design_spec, context)

        print(f"[Gradio Dev] Generated {len(gradio_code)} characters of code")
        print("[Gradio Dev] Implementation complete")

        self.emit('gradio_developer', f"[OK] Implementation complete!", {
            'code_length': len(gradio_code)
        })

        return gradio_code


# Entry point
if __name__ == "__main__":
    runner = AgentChatRunnerV2()
    runner.run()
